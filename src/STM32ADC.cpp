#include "STM32ADC.h"
#include "PinConfigured.h"

static uint32_t STM32ADC_RES = 0;
static uint32_t adcIntrCount = 0;

static ADC_HandleTypeDef hadc = {};

STM32ADC* STM32ADC::_instance = NULL;

void STM32ADC::setResolution(int r) {
    switch (r) {
        case 10:
            _resolution = ADC_RESOLUTION_10B;
            break;
        case 8:
            _resolution = ADC_RESOLUTION_8B;
            break;
        case 6:
            _resolution = ADC_RESOLUTION_6B;
            break;
        case 12:
        default:
            _resolution = ADC_RESOLUTION_12B;
            break;
    }
}

bool STM32ADC::begin() {
    uint32_t bank = 0;
    ADC_ChannelConfTypeDef  chConf = {};
    PinName pin = analogInputToPinName(_ulPin);

    if ((pin & PADC_BASE) && (pin < ANA_START)) {
#if defined(STM32H7xx) || defined(STM32MP1xx)
#ifdef ADC3
        hadc.Instance = ADC3;
#else
        hadc.Instance = ADC2;
#endif
#else
        hadc.Instance = ADC1;
#if defined(ADC5) && defined(ADC_CHANNEL_TEMPSENSOR_ADC5)
        if (pin == PADC_TEMP_ADC5) {
            hadc.Instance = ADC5;
        }
#endif
#endif
        _channel = get_adc_internal_channel(pin);
    } else {
        hadc.Instance = (ADC_TypeDef *)pinmap_peripheral(pin, PinMap_ADC);
        _channel = get_adc_channel(pin, &bank);
    }

    if (hadc.Instance == NP) {
        return false;
    }

    hadc.Init.ClockPrescaler = _clockPrescaler;
    hadc.Init.Resolution = _resolution;
    hadc.Init.ScanConvMode = DISABLE; // not implemented
    hadc.Init.ContinuousConvMode = _continuousConvMode;
    hadc.Init.DiscontinuousConvMode = DISABLE; // not implemented
    hadc.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
    hadc.Init.ExternalTrigConv = ADC_SOFTWARE_START;
    hadc.Init.DataAlign = ADC_DATAALIGN_RIGHT;
    hadc.Init.NbrOfConversion = 1;
    hadc.Init.DMAContinuousRequests = DISABLE; // not implemented 
    hadc.Init.EOCSelection = ADC_EOC_SINGLE_CONV;

    // g_current_pin = pin; /* Needed for HAL_ADC_MspInit*/
    if (HAL_ADC_Init(&hadc) != HAL_OK) {
        return false;
    }

    /*
       HAL_ADC_Init calls HAL_ADC_MspInit which enables the ADC clock 
       and configures the current pin passed via a static variable from adc_read_value! 
       We can't redefine HAL_ADC_MspInit as it's not __weak
       So we need to configure the pin here.
    */
    if (!(pin & PADC_BASE)) {
      /*
        It doesn't work if trying directly as follows (as generated by STM32CubeIDE).
        
        GPIO_InitTypeDef gpioInit;
        __GPIOA_CLK_ENABLE(); // or whatever bank
        gpioInit.Pin = pin;
        gpioInit.Mode = GPIO_MODE_ANALOG;
        gpioInit.Pull = GPIO_NOPULL;
        HAL_GPIO_Init(bank, &gpioInit);

        One way is to do a dummy analogRead on the current pin at the begining of this function.
        That seems to leave the pin configured properly.
        
        But the pinmap_pinout function used in HAL_ADC_MspInit does the right thing.
       */
        pinmap_pinout(pin, PinMap_ADC);
    }

    if ( _useInterrupt ) {
        HAL_NVIC_SetPriority(ADC_IRQn, 0, 0);
        HAL_NVIC_EnableIRQ(ADC_IRQn);
    }

    chConf.Channel = _channel;
    chConf.Rank = 1;
    chConf.SamplingTime = _samplingTime;
    if (HAL_ADC_ConfigChannel(&hadc, &chConf) != HAL_OK)
    {
        return false;
    }

    // request the conversion right away if in interrupt mode
    if ( _useInterrupt ) {
        HAL_ADC_Start_IT(&hadc);
    }
    return true;
}

uint32_t STM32ADC::getValue() {
    if (!_useInterrupt)
    {
        HAL_ADC_Start(&hadc);
        HAL_ADC_PollForConversion(&hadc, 2);
        STM32ADC_RES = HAL_ADC_GetValue(&hadc);
    }
    return STM32ADC_RES;
}

uint32_t STM32ADC::getInterrupts() {
    uint32_t c = adcIntrCount;
    // reset count
    adcIntrCount=0;
    return c;
}

#ifdef __cplusplus
extern "C" {
#endif

void ADC_IRQHandler(void)
{
  HAL_ADC_IRQHandler(&hadc);
}

void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* hadc0)
{
    STM32ADC_RES = HAL_ADC_GetValue(&hadc);
    adcIntrCount++;
    STM32ADC::onADCInterrupt();
}

#ifdef __cplusplus
}
#endif
