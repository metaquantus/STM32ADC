#include "STM32ADC.h"
#include "PinConfigured.h"

static uint32_t STM32ADC_RES = 0;
static uint32_t adcIntrCount = 0;

static ADC_HandleTypeDef hadc = {};

STM32ADC* STM32ADC::_instance = NULL;

void STM32ADC::setResolution(int r) {
    switch (r) {
        case 10:
            _resolution = ADC_RESOLUTION_10B;
            break;
        case 8:
            _resolution = ADC_RESOLUTION_8B;
            break;
        case 6:
            _resolution = ADC_RESOLUTION_6B;
            break;
        case 12:
        default:
            _resolution = ADC_RESOLUTION_12B;
            break;
    }
}

bool STM32ADC::begin() {
    PinName pin = analogInputToPinName(_ulPin);


    uint32_t bank = 0;
    ADC_ChannelConfTypeDef  chConf = {};

    _channel = get_adc_channel(pin, &bank);
    
    hadc.Instance = ADC1; // STM32F411 only has ADC1, need to make this more generic (copy code from adc_read_value)
    hadc.Init.ClockPrescaler = _clockPrescaler;
    hadc.Init.Resolution = _resolution;
    hadc.Init.ScanConvMode = DISABLE; // not implemented
    hadc.Init.ContinuousConvMode = _continuousConvMode;
    hadc.Init.DiscontinuousConvMode = DISABLE; // not implemented
    hadc.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
    hadc.Init.ExternalTrigConv = ADC_SOFTWARE_START;
    hadc.Init.DataAlign = ADC_DATAALIGN_RIGHT;
    hadc.Init.NbrOfConversion = 1;
    hadc.Init.DMAContinuousRequests = DISABLE; // not implemented 
    hadc.Init.EOCSelection = ADC_EOC_SINGLE_CONV;

    // g_current_pin = pin; /* Needed for HAL_ADC_MspInit*/
    if (HAL_ADC_Init(&hadc) != HAL_OK) {
        return false;
    }

    // HAL_ADC_Init calls HAL_ADC_MspInit which configures the current pin
    // passed via a static variable from adc_read_value! 
    // We can't redefine HAL_ADC_MspInit as it's not __weak
    // So we need to configure the pin here.
    // HAL_ADC_MspInit also enables the ADC clock, so we don't needed here.
    if (!(pin & PADC_BASE))
    {
      /*
        It doesn't work if I try directly as follows (as generated by STM32CubeIDE).
        
        GPIO_InitTypeDef gpioInit;
        __GPIOA_CLK_ENABLE(); // or whatever bank
        gpioInit.Pin = pin;
        gpioInit.Mode = GPIO_MODE_ANALOG;
        gpioInit.Pull = GPIO_NOPULL;
        HAL_GPIO_Init(bank, &gpioInit);

        One way is to do a dummy analogRead on the current pin at the begining of this function.
        That seems to leave the pin configured properly.
        
        But the pinmap_pinout function used in HAL_ADC_MspInit does the right thing.
       */
        pinmap_pinout(pin, PinMap_ADC);
    }

    if ( _useInterrupt ) {
        HAL_NVIC_SetPriority(ADC_IRQn, 0, 0);
        HAL_NVIC_EnableIRQ(ADC_IRQn);
    }

    chConf.Channel = _channel;
    chConf.Rank = 1;
    chConf.SamplingTime = _samplingTime;
    if (HAL_ADC_ConfigChannel(&hadc, &chConf) != HAL_OK)
    {
        return false;
    }

    // request the conversion right away if in interrupt mode
    if ( _useInterrupt ) {
        HAL_ADC_Start_IT(&hadc);
    }
    return true;
}

uint32_t STM32ADC::getValue() {
    if (!_useInterrupt)
    {
        HAL_ADC_Start(&hadc);
        HAL_ADC_PollForConversion(&hadc, 2);
        STM32ADC_RES = HAL_ADC_GetValue(&hadc);
    }
    return STM32ADC_RES;
}

uint32_t STM32ADC::getInterrupts() {
    uint32_t c = adcIntrCount;
    // reset count
    adcIntrCount=0;
    return c;
}

#ifdef __cplusplus
extern "C" {
#endif

void ADC_IRQHandler(void)
{
  HAL_ADC_IRQHandler(&hadc);
}

void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* hadc0)
{
    STM32ADC_RES = HAL_ADC_GetValue(&hadc);
    adcIntrCount++;
    STM32ADC::onADCInterrupt();
}

#ifdef __cplusplus
}
#endif
