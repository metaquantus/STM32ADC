#include "STM32ADC.h"
#include "PinConfigured.h"

static uint32_t STM32ADC_RES = 0;
static uint32_t adcIntrCount = 0;

static ADC_HandleTypeDef hadc = {};
static DMA_HandleTypeDef hdma_adc1;

STM32ADC* STM32ADC::_instance = NULL;

void STM32ADC::setResolution(int r) {
    switch (r) {
        case 10:
            _resolution = ADC_RESOLUTION_10B;
            break;
        case 8:
            _resolution = ADC_RESOLUTION_8B;
            break;
        case 6:
            _resolution = ADC_RESOLUTION_6B;
            break;
        case 12:
        default:
            _resolution = ADC_RESOLUTION_12B;
            break;
    }
}

int STM32ADC::addChannel(uint32_t ulPin, uint32_t samplingTime) {
    if (_channels < STM32ADC_MAX_CHANNELS) {
        int rank = _channels++;
        _ulPins[rank] = ulPin;
        _samplingTimes[rank] = samplingTime;
        return rank + 1; // 1-based to match STM32 rank numbering convention
    } else {
        return -1;
    }
}

bool STM32ADC::begin() {
    if ( _channels <= 0 ) {
        // nothing to convert
        return false;
    }
    uint32_t bank = 0;
    
    // use first channel to find ADC unit
    PinName pin = analogInputToPinName(_ulPins[0]);

    if ((pin & PADC_BASE) && (pin < ANA_START)) {
#if defined(STM32H7xx) || defined(STM32MP1xx)
#ifdef ADC3
        hadc.Instance = ADC3;
#else
        hadc.Instance = ADC2;
#endif
#else
        hadc.Instance = ADC1;
#if defined(ADC5) && defined(ADC_CHANNEL_TEMPSENSOR_ADC5)
        if (pin == PADC_TEMP_ADC5) {
            hadc.Instance = ADC5;
        }
#endif
#endif
        // _channel = get_adc_internal_channel(pin);
    } else {
        hadc.Instance = (ADC_TypeDef *)pinmap_peripheral(pin, PinMap_ADC);
        // _channel = get_adc_channel(pin, &bank);
    }

    if (hadc.Instance == NP) {
        return false;
    }

    hadc.Init.ClockPrescaler = _clockPrescaler;
    hadc.Init.Resolution = _resolution;
    hadc.Init.ScanConvMode = _continuousConvMode; // enable only in continuous mode
    hadc.Init.ContinuousConvMode = _continuousConvMode;
    hadc.Init.DiscontinuousConvMode = DISABLE; // not implemented
    hadc.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
    hadc.Init.ExternalTrigConv = ADC_SOFTWARE_START;
    hadc.Init.DataAlign = ADC_DATAALIGN_RIGHT;
    hadc.Init.NbrOfConversion = _channels;
    hadc.Init.DMAContinuousRequests = _continuousConvMode;  // use DMA in continuous conversion mode
    hadc.Init.EOCSelection = ADC_EOC_SEQ_CONV; // trigger interrupt at end of conversion sequence

    // g_current_pin = pin; /* Needed for HAL_ADC_MspInit*/
    if (HAL_ADC_Init(&hadc) != HAL_OK) {
        return false;
    }

    // configure the registered channels
    for (int rank = 0; rank < _channels; rank++) {
        ADC_ChannelConfTypeDef chConf = {};
        uint32_t rbank = 0;
        uint32_t channel = ADC_CHANNEL_0;
        PinName rpin = analogInputToPinName(_ulPins[rank]);
        
        if ((rpin & PADC_BASE) && (rpin < ANA_START)) {
            channel = get_adc_internal_channel(rpin);
        } else {
            channel = get_adc_channel(rpin, &rbank);
        }
        /*
           HAL_ADC_Init calls HAL_ADC_MspInit which enables the ADC clock
           and configures the current pin passed via a static variable from
           adc_read_value! We can't redefine HAL_ADC_MspInit as it's not __weak
           So we need to configure the pin here.
        */
        if (!(rpin & PADC_BASE)) {
            /*
              It doesn't work if trying directly as follows (as generated by
              STM32CubeIDE).

              GPIO_InitTypeDef gpioInit;
              __GPIOA_CLK_ENABLE(); // or whatever bank
              gpioInit.Pin = pin;
              gpioInit.Mode = GPIO_MODE_ANALOG;
              gpioInit.Pull = GPIO_NOPULL;
              HAL_GPIO_Init(bank, &gpioInit);

              One way is to do a dummy analogRead on the current pin at the
              begining of this function. That seems to leave the pin configured
              properly.

              But the pinmap_pinout function used in HAL_ADC_MspInit does the
              right thing.
             */
            pinmap_pinout(rpin, PinMap_ADC);
        }

        chConf.Channel = channel;
        chConf.Rank = rank+1;
        chConf.SamplingTime = _samplingTimes[rank];
        if (HAL_ADC_ConfigChannel(&hadc, &chConf) != HAL_OK) {
            return false;
        }
    }
    // all good, setup DMA transfers
    // NOTE: This may only work for STM32F411
    if (hadc.Instance == ADC1) {
        /* DMA controller clock enable */
        __HAL_RCC_DMA2_CLK_ENABLE();

        /* DMA interrupt init */
        /* DMA2_Stream0_IRQn interrupt configuration */
        if (_useInterrupt) {
            HAL_NVIC_SetPriority(DMA2_Stream0_IRQn, 0, 0);
            HAL_NVIC_EnableIRQ(DMA2_Stream0_IRQn);
        }

        /* ADC1 DMA Init */
        /* ADC1 Init */
        hdma_adc1.Instance = DMA2_Stream0; // this is probably only valid for STM32F411, 
                          // TODO: determine for other MCUs
        hdma_adc1.Init.Channel = DMA_CHANNEL_0;
        hdma_adc1.Init.Direction = DMA_PERIPH_TO_MEMORY;
        hdma_adc1.Init.PeriphInc = DMA_PINC_DISABLE;
        hdma_adc1.Init.MemInc = DMA_MINC_ENABLE;
        hdma_adc1.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD; // 16 bits
        hdma_adc1.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;    // 16 bits
        hdma_adc1.Init.Mode =
            _continuousConvMode == ENABLE ? DMA_CIRCULAR : DMA_NORMAL;
        hdma_adc1.Init.Priority = DMA_PRIORITY_LOW;
        hdma_adc1.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
        if (HAL_DMA_Init(&hdma_adc1) != HAL_OK) {
            return false;
        }
        __HAL_LINKDMA(&hadc, DMA_Handle, hdma_adc1);
    }
    if ( _useInterrupt ) {
        HAL_NVIC_SetPriority(ADC_IRQn, 0, 0);
        HAL_NVIC_EnableIRQ(ADC_IRQn);
    }
    _connected = true;

    return true;
}

bool STM32ADC::end() {
    if ( _useInterrupt ) {
        HAL_NVIC_DisableIRQ(ADC_IRQn);
    }
    
    if (HAL_ADC_Stop(&hadc) != HAL_OK) {
        /* Stop Conversation Error */
        return false;
    }

    /* ADC1 DMA DeInit */
    HAL_DMA_DeInit(hadc.DMA_Handle);

    if (HAL_ADC_DeInit(&hadc) != HAL_OK) {
        return false;
    }

    if (__LL_ADC_COMMON_INSTANCE(hadc.Instance) != 0U) {
        LL_ADC_SetCommonPathInternalCh(
            __LL_ADC_COMMON_INSTANCE(AdcHandle.Instance),
            LL_ADC_PATH_INTERNAL_NONE);
    }
    _connected = false;
    return true;
}

void STM32ADC::start() {
    _started = true;
    if (_useInterrupt) {
        // use DMA mode even if only one channel
        HAL_ADC_Start_DMA(&hadc, (uint32_t*) _dmaBuf, _channels);
    }
}

uint32_t STM32ADC::getValue(int rank) {
    if (!_started) {
        start();
    }
    if (!_useInterrupt)
    {
        HAL_ADC_Start(&hadc);
        HAL_ADC_PollForConversion(&hadc, 2);
        STM32ADC_RES = HAL_ADC_GetValue(&hadc);
    }
    if ( rank > 0 && rank <= _channels) {
        return _dmaBuf[rank-1];
    }
    return STM32ADC_RES;
}

// count interrupts between calls to this function
// just for debugging
uint32_t STM32ADC::getInterrupts() {
    uint32_t c = adcIntrCount;
    // reset count
    adcIntrCount=0;
    return c;
}

#ifdef __cplusplus
extern "C" {
#endif

void ADC_IRQHandler(void)
{
  HAL_ADC_IRQHandler(&hadc);
}

void DMA2_Stream0_IRQHandler(void)
{
  HAL_DMA_IRQHandler(&hdma_adc1);
}

void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* hadc0)
{
    // this just gets the last conversion
    STM32ADC_RES = HAL_ADC_GetValue(&hadc);
    adcIntrCount++;
    // data should be in _dmaBuf
    STM32ADC::onADCInterrupt();
}

void HAL_ADC_ErrorCallback(ADC_HandleTypeDef *hadc0)
{
  STM32ADC::onADCError();
}

#ifdef __cplusplus
}
#endif
